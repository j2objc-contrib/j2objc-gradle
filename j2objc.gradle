/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author: Bruno Bowden
 *
 *
 * Description:
 * This is gradle script for j2objc (Java to Objective-C translator). This allows you to
 * share code between Android and iOS plaforms. The plugin works well with Android Studio
 * (which uses Gradle by default). The system works best if you have a large shared codebase
 * with NO Android dependencies (built with gradle). Have your main Android application depend
 * on that shared project. Within Xcode, you add the translated code and compile it.
 * j2objc by design doesn't translate UI code and expects you to write that in the
 * native language of each platform.
 *
 * For the latest version and to submit patches:
 *     https://github.com/brunobowden/j2objc-gradle
 *
 * j2objc:
 *     https://github.com/google/j2objc/wiki
 *
 *
 * Usage:
 * 1) Download a j2objc release and unzip it to a directory:
 *     https://github.com/google/j2objc/releases
 * 2) Copy this file (j2objc.gradle) next to the build.gradle file of the project to be translated
 * 3) Copy and paste the following to your project's build.gradle file
 *     (it's currently best to run "gradlew clean" when changing this configuration)

    apply from: 'j2objc.gradle'

    j2objcConfig {

        // MODIFY to where your unzipped j2objc directory is located
        // NOTE download the latest version from: https://github.com/google/j2objc/releases
        j2objcHome null  // e.g. "${projectDir}/../../j2objc or absolute path

        // MODIFY to where generated objc files should be put for Xcode project
        // NOTE these files should be checked in to the repository and updated as needed
        // NOTE this should contain ONLY j2objc generated files, other contents will be deleted
        destDir null  // e.g. "${projectDir}/../Xcode/j2objc-generated"

        // Further settings are listed in the "J2objcPluginExtension" class below
    }

 * 4) Run command to generate and copyfiles. This will only succeed if all steps succeed.
 *
 *     $ gradlew <SHARED_PROJECT>:j2objcCopy
 *
 * Commands:
 * Each one depends on the previous command
 *     j2objcCycleFinder - Find cycles that can cause memory leaks, see https://github.com/google/j2objc/wiki/Cycle-Finder-Tool
 *     j2objcTranslate   - Translates to Objective-C, depends on java or Android project if found
 *     j2objcCompile     - Compile Objective-C files and build Objective-C binary (named 'runner')
 *     j2objcTest        - Run all java tests against the Objective-C binary
 *     j2objcCopy        - Copy generated Objective-C files to Xcode project
 *     j2objcXcode       - Xcode project file import and target configuration
 *
 * Note that you can use the Gradle shorthand of "$ gradlew jCop" to do the j2objcCopy task.
 * The other shorthand expressions are "jTr", "jCom" and "jTe"
 *
 * Thanks to Peter Niederwieser and 'bigguy' from Gradleware
 */

// TODO: add plugin tests

// TODO: 'apply' should be done in build.gradle, move there as this becomes a proper plugin
apply plugin: j2objc


// Further configuration uses the following fields, setting them in j2objcConfig within build.gradle
class J2objcPluginExtension {

    // Where to copy generated files (excludes test code and executable)
    String destDir = null

    // Only generated source files, e.g. from dagger annotations. The script will
    // ignore changes in this directory so they must be limited to generated files.
    String generatedSourceDir = null 
    
    // Path to j2objc distribution
    String j2objcHome = null

    // TRANSLATE
    // Flags copied verbatim to j2objc command
    String translateFlags = "--no-package-directories"
    // -classpath library additions from ${projectDir}/lib/, e.g.: "json-20140107.jar", "somelib.jar"
    String[] translateClassPaths = []
    
    // Additional libraries that are part of the j2objc release
    // TODO: warn if different versions than testCompile from Java plugin
    // TODO: just import everything in the j2objc/lib/ directory?
    // J2objc default libraries, from $J2OBJC_HOME/lib/...
    String[] translateJ2objcLibs = [
            // Memory annotations, e.g. @Weak, @AutoreleasePool
            "j2objc_annotations.jar",
            // Libraries that have CycleFinder fixes, e.g. @Weak and code removal
            "j2objc_guava.jar", "j2objc_junit.jar", "jre_emul.jar",
            // Libraries that don't need CycleFinder fixes
            "javax.inject-1.jar", "jsr305-3.0.0.jar",
            "mockito-core-1.9.5.jar"]
    // Filter on files to translate:
    // a) Regexes are ignored if null
    // b) Matches on path + filename
    // c) Must match IncludeRegex and NOT match ExcludeRegex
    // Example:
    //     translateExcludeRegex ".*/src/(main|test)/java/com/example/EXCLUDE_DIR/.*"
    //     translateIncludeRegex ".*/TranslateOnlyMeAnd(|Test)\\.java"
    String translateExcludeRegex = null
    String translateIncludeRegex = null
    // TODO: consider moving to include(s) / exclude(s) structure as used for filetree

    // Translation task additional paths
    // e.g., ${projectDir}/libSrc/dagger-2.0-SNAPSHOT-sources.jar:${projectDir}/libSrc/javax.inject-1-sources.jar
    // TODO dagger2 should be detected and automatically change this parameter
    String translateSourcepaths = null

    // Set to true if java project dependencies of the current project should be appended to the sourcepath
    // automatically.  You will most likely want to use --build-closure in the translateFlags as well.
    boolean appendProjectDependenciesToSourcepath = false
}


class J2objcUtils {
    // TODO: ideally bundle j2objc binaries with plugin jar and load at runtime with
    // TODO: ClassLoader.getResourceAsStream(), extract, chmod and then execute

    static isWindows() {
        return System.getProperty("os.name").toLowerCase().contains("windows")
    }

    static def j2objcHome(Project proj) {
        def result = proj.j2objcConfig.j2objcHome
        if (result == null) {
            def message =
                "j2objcHome not set, this should be configured in the parent gradle file with " +
                "this syntax:\n" +
                "\n" +
                "j2objcConfig {\n" +
                "    j2objcHome null // e.g. \"\${projectDir}/../j2objc\"\n" +
                "}\n" +
                "\n" +
                "It must be the path of the unzipped j2objc release. Download releases here:\n" +
                "https://github.com/google/j2objc/releases"
            throw new InvalidUserDataException(message)
        }
        if (!proj.file(result).exists()) {
            def message = "j2objc directory not found, expected location: ${result}"
            throw new InvalidUserDataException(message)
        }
        return result
    }

    // Filters a FileCollection by path:
    // must match includeRegex and NOT match excludeRegex, regex ignored if null
    static def fileFilter(FileCollection files, String includeRegex, String excludeRegex) {
        return files.filter { file ->
            if (includeRegex == null)
                return true
            return file.path.matches(includeRegex)
        }.filter { file ->
            if (excludeRegex == null)
                return true
            return ! file.path.matches(excludeRegex)
        }
    }

    // Reads both settings from translateFlags (last flag takes precedence)
    //   --prefixes dir/prefixes.properties --prefix com.ex.dir=Short --prefix com.ex.dir2=Short2
    static def prefixProperties(Project proj) {
        Properties props = new Properties()
        def matcher = (proj.j2objcConfig.translateFlags =~ /--prefix(|es) +([^-]+)/)
        def start = 0
        while (matcher.find(start)) {
            start = matcher.end()
            def newProps = new Properties()
            def argValue = matcher.group(2)
            if (matcher.group(1) == "es") {
                // --prefixes prefixes.properties
                // trailing space confuses FileInputStream
                def prefixesPath = argValue.trim()
                newProps.load(new FileInputStream(proj.file(prefixesPath).path))
            } else {
                // --prefix com.example.dir=CED
                newProps.load(new StringReader(argValue.trim()));
            }
            props.putAll(newProps)
        }
//        for (key in props.keys()) {
//            println key + ": " + props.getProperty(key)
//        }

        return props
    }

    // TODO: apply prefixes before doing collission check
    static def filenameCollisionCheck(FileCollection files) {
        def nameMap = [:]
        for (file in files) {
            if (nameMap.containsKey(file.name)) {
                def prevFile = nameMap.get(file.name)
                def message =
                        "File name collision detected:\n" +
                        "  " + prevFile.path + "\n" +
                        "  " + file.path + "\n" +
                        "\n" +
                        "To disable this check (which may overwrite output files):\n" +
                        "j2objcConfig {\n" +
                        "    filenameCollisionCheck false\n" +
                        "}\n"
                throw new InvalidUserDataException(message)
            }
            nameMap.put(file.name, file)
        }
    }

    // add Java files to a FileCollection
    static def addJavaFiles(Project proj, FileCollection files, String generatedSourceDir) {
        if (generatedSourceDir) {
            println "include generatedSourceDir: "+generatedSourceDir
            def buildSrcFiles = proj.files(proj.fileTree(dir: generatedSourceDir, includes: ["**/*.java"]))
            files += buildSrcFiles
        }
        return files
    }

    static def absolutePathOrEmpty(Project proj, String relativePath) {
        if (relativePath) {
            println "Added to Path: " + relativePath
            return ":${proj.file(relativePath).path}"
        } else {
            return ""
        }
    }
    
    // -classpath javac flag generation from set of libraries (includes j2objc default libraries)
    static def getClassPathArg(Project proj, String[] libraries) {
        def classPathList = []
        // user defined libraries
        libraries.each { library ->
            def libPath = "${proj.projectDir}/lib/" + library
            classPathList += libPath
        }
        // j2objc default libraries
        proj.j2objcConfig.translateJ2objcLibs.each { library ->
            classPathList += j2objcHome(proj) + "/lib/" + library
        }
        return classPathList.join(':')
    }
}


class J2objcCycleFinderTask extends DefaultTask {

    // TODO(bruno): consider enabling cycleFinder by default
    @Input
    boolean skip = true
    // Flags copied verbatim to cycle_finder command
    @Input
    String cmdArgs = ""
    // Expected number of cycles, defaults to all those found in JRE
    // TODO(bruno): convert to a default whitelist and change expected cyles to 0
    @Input
    int expectedCycles = 40
    @InputFiles
    FileCollection srcFiles
    @OutputFile
    File reportFile = project.file("${project.buildDir}/reports/${name}.out")

    @TaskAction
    def cycleFinder() {
        if (skip) {
            println "Skipping j2objcCycleFinder"
            return
        }

        def j2objcHome = J2objcUtils.j2objcHome(getProject())
        def cycleFinderExec = j2objcHome + "/cycle_finder"
        def windowsOnlyArgs = ""
        if (J2objcUtils.isWindows()) {
            cycleFinderExec = "java"
            windowsOnlyArgs = "-jar ${j2objcHome}/lib/cycle_finder.jar"
        }

        if (cmdArgs == null) {
            // TODO: need to updated all the j2objcConfig comments
            def message =
                    "CycleFinder is more difficult to setup and use, though it's hoped to improve\n" +
                    "this for the future. For now there are two ways to set it up:\n" +
                    "\n" +
                    "SIMPLE: set cycleFinderFlags to empty string:\n" +
                    "    j2objcConfig {\n" +
                    "        cycleFinder true\n" +
                    "        cycleFinderFlags \"\"\n" +
                    "    }\n" +
                    "\n" +
                    "DIFFICULT:\n" +
                    "1) Download the j2objc source:\n" +
                    "    https://github.com/google/j2objc\n" +
                    "2) Within your local j2objc repo run:\n" +
                    "    \$ (cd jre_emul && make java_sources_manifest)\n" +
                    "3) Configure j2objcConfig in build.gradle so CycleFinder uses j2objc source:\n" +
                    "    j2objcConfig {\n" +
                    "        cycleFinder true\n" +
                    "        cycleFinderFlags (\n" +
                    "                \"--whitelist \${projectDir}/../../<J2OBJC_REPO>/jre_emul/cycle_whitelist.txt \\\n" +
                    "                 --sourcefilelist \${projectDir}/../../<J2OBJC_REPO>/jre_emul/build_result/java_sources.mf\")\n" +
                    "        cycleFinderExpectedCycles 0\n" +
                    "    }\n" +
                    "Also see: https://groups.google.com/forum/#!msg/j2objc-discuss/2fozbf6-liM/R83v7ffX5NMJ"
            throw new InvalidUserDataException(message)
        }

        def sourcepath = "${project.file("src/main/java").path}:${project.file("src/test/java").path}"

        // Generated Files
        srcFiles = J2objcUtils.addJavaFiles(
                project, srcFiles, project.j2objcConfig.generatedSourceDir)
        sourcepath += J2objcUtils.absolutePathOrEmpty(
                project, project.j2objcConfig.generatedSourceDir)

        // Additional Sourcepaths, e.g. source jars
        if (project.j2objcConfig.translateSourcepaths) {
            println "Add to sourcepath: ${project.j2objcConfig.translateSourcepaths}"
            sourcepath += ":${project.j2objcConfig.translateSourcepaths}"
        }

        srcFiles = J2objcUtils.fileFilter(srcFiles,
                project.j2objcConfig.translateIncludeRegex,
                project.j2objcConfig.translateExcludeRegex)

        def classPathArg = J2objcUtils.getClassPathArg(
                project, project.j2objcConfig.translateClassPaths)

        def output = new ByteArrayOutputStream()
        try {
            project.exec {
                executable cycleFinderExec

                args windowsOnlyArgs.split()
                args "-sourcepath", sourcepath

                if (classPathArg.size() > 0) {
                    args "-classpath", classPathArg
                }

                args cmdArgs.split()

                srcFiles.each { file ->
                    args file.path
                }

                errorOutput output;
                standardOutput output;
            }

        } catch (e) {

            def out = output.toString()

            def matcher = (out =~ /(\d+) CYCLES FOUND/)
            if (! matcher.find()) {
                print out
                throw new InvalidUserDataException("Can't find XX CYCLES FOUND")
            } else {
                def cycleCountStr = matcher[0][1]
                if (! cycleCountStr.isInteger()) {
                    print out
                    throw new InvalidUserDataException("XX CYCLES FOUND isn't integer: " + matcher[0][0])
                }
                def cyclesFound = cycleCountStr.toInteger()
                if (cyclesFound != expectedCycles) {
                    print out
                    print ("Cycles found (" + cyclesFound + ") != expectedCycles (" +
                            expectedCycles + ")    ")
                    throw e
                }
            }
            // Suppressed exception for cycle count == expectedCycles
        }

        reportFile.write(output.toString())
        println "CycleFinder Output: ${reportFile.path}"
    }
}


// TODO: do translations and other tasks incrementally
class J2objcTranslateTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @Input
    String cmdArgs = "FAILURE"
    // Xcode doesn't support directories for packages, so all files must be output
    // to a single directory. This check makes sure that the name don't collide.
    // TODO: automatically enable with --no-package-directories
    @Input
    boolean filenameCollisionCheck = true
    @InputFiles
    FileCollection srcFiles
    @OutputDirectory
    File destDir

    @TaskAction
    def translate(IncrementalTaskInputs inputs) {
        // TODO DO NOT SUBMIT - apply prefixes
        println "Source files: "+srcFiles.getFiles().size()
        FileCollection srcFilesChanged = project.files()
        inputs.outOfDate { change ->
            println "New or Updated file: "+change.file
            srcFilesChanged += project.files(change.file)
        }
        def removedFileNames = []
        inputs.removed { change ->
            println "Removed file: "+change.file.name
            def nameWithoutExt = file.name.toString().replaceFirst("\\..*","")
            removedFileNames += nameWithoutExt
        }
        println "Removed files: "+removedFileNames.size()
        
        println "New or Updated files: "+srcFilesChanged.getFiles().size()
        FileCollection translatedSrcFiles = srcFiles - srcFilesChanged
        println "Unchanged files: "+translatedSrcFiles.getFiles().size()

        if (destDir.exists()) {
            FileCollection destFiles = project.files(project.fileTree(
                        dir: destDir, includes: ["**/*.h", "**/*.m"]))
            
            // remove translated .h and .m files which has no corresponding .java files anymore
            destFiles.each {File file ->
                def nameWithoutExt = file.name.toString().replaceFirst("\\..*","")
                if (removedFileNames.contains(nameWithoutExt)) {
                    file.delete()
                }
            }
        }

        // set the srcFiles to the files which need to be translated
        srcFiles = srcFilesChanged

        def j2objcHome = J2objcUtils.j2objcHome(getProject())
        def j2objcExec = j2objcHome + "/j2objc"
        def windowsOnlyArgs = ""
        if (J2objcUtils.isWindows()) {
            j2objcExec = "java"
            windowsOnlyArgs = "-jar ${j2objcHome}/lib/j2objc.jar"
        } 
       
        def sourcepath = "${project.file("src/main/java").path}:${project.file("src/test/java").path}"

        // Additional Sourcepaths, e.g. source jars
        if (project.j2objcConfig.translateSourcepaths) {
            println "Add to sourcepath: ${project.j2objcConfig.translateSourcepaths}"
            sourcepath += ":${project.j2objcConfig.translateSourcepaths}"
        }

        // Generated Files
        sourcepath += J2objcUtils.absolutePathOrEmpty(project, project.j2objcConfig.generatedSourceDir)

        // Project Dependencies
        if (project.j2objcConfig.appendProjectDependenciesToSourcepath) {
            def depSourcePaths = []
            project.configurations.compile.allDependencies.each { dep ->
                if (dep instanceof ProjectDependency) {
                    def depProj = ((ProjectDependency)dep).getDependencyProject()
                    depSourcePaths += depProj.sourceSets.main.java.srcDirs
                }
            }
            sourcepath += ':' + depSourcePaths.join(':')
        }

        srcFiles = J2objcUtils.fileFilter(srcFiles,
                project.j2objcConfig.translateIncludeRegex,
                project.j2objcConfig.translateExcludeRegex)

        // TODO DO NOT SUBMIT
        // TODO perform file collision check with already translated files in the destDir
        if (filenameCollisionCheck) {
            J2objcUtils.filenameCollisionCheck(srcFiles)
        }
     
        def classPathArg = J2objcUtils.getClassPathArg(
                project, project.j2objcConfig.translateClassPaths)

        // TODO add translated .class files to classpath for incremental translation

        try {
            project.exec {
                executable j2objcExec

                args windowsOnlyArgs.split()
                args "-d", "${destDir}"
                args "-sourcepath", sourcepath

                if (classPathArg.size() > 0) {
                    args "-classpath", classPathArg
                }
                
                args cmdArgs.split()

                srcFiles.each { file ->
                    args file.path
                }
            }

        } catch (e) {
            // Warn and explain typical case of Android application, then rethrow error
            if (! project.plugins.findPlugin('java')) {
                if (project.j2objcConfig.translateIncludeRegex == null &&
                    project.j2objcConfig.translateIncludeRegex == null) {

                    def message =
                        "\n" +
                        "J2objc by design will not translate your entire Android application.\n" +
                        "It focuses on the business logic, the UI should use native code:\n" +
                        "  https://github.com/google/j2objc/blob/master/README.md\n" +
                        "\n" +
                        "The best practice over time is to separate out the shared code to a\n" +
                        "distinct java project with NO android dependencies.\n" +
                        "\n" +
                        "As a step towards that, you can configure the j2objc plugin to only\n" +
                        "translate a subset of files that don't depend on Android. The settings\n" +
                        "are regular expressions on the file path. For example:\n" +
                        "\n" +
                        "j2objcConfig {\n" +
                        "    translateIncludeRegex \".*/src/main/java/com/example/TranslateThisDirectoryOnly/.*\n" +
                        "    translateExcludeRegex \".*/(SkipThisClass|AlsoSkipThisClass)\\.java\"\n" +
                        "}\n"

                    print message
                }
            }

            throw e
        }
    }
}


class J2objcCompileTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @Input
    String compileFlags = "-ObjC -lguava -ljavax_inject -ljre_emul -ljsr305 -ljunit -lmockito"
    @InputDirectory
    File srcDir
    @OutputFile
    File destFile

    @TaskAction
    def compile() {

        if (J2objcUtils.isWindows()) {
            throw new InvalidUserDataException(
                    "Windows only supports j2objc translation. To compile and test code, " +
                            "please develop on a Mac.");
        }

        def binary = J2objcUtils.j2objcHome(getProject()) + "/j2objcc"
        // TODO: copy / reference test resources

        // No include / exclude regex as unlikely for compile to fail after successful translation

        println "Compiling test binary: " + destFile.path
        project.exec {
            executable binary
            args "-I${srcDir}"
            args "-o", "${destFile.path}"

            args compileFlags.split()

            def srcFiles = project.files(project.fileTree(
                    dir: srcDir, includes: ["**/*.h", "**/*.m"]))
            srcFiles.each { file ->
                args file.path
            }
        }
    }
}


class J2objcTestTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    // Flags copied verbatim to testrunner command
    @Input
    String cmdArgs = ""
    // Filter tests, applied in addition to translate filters (see above)
    @Input
    String testExcludeRegex = "^\$"  // default: exclude none
    @Input
    String testIncludeRegex = ".*"  // default: include all
    // Warn if no tests are executed
    @Input
    boolean testExecutedCheck = true
    @InputFile
    File srcFile  // testrunner
    @InputFiles
    FileCollection srcFiles  // *Test.java
    @OutputFile
    File reportFile = project.file("${project.buildDir}/reports/${name}.out")

    @TaskAction
    def test() {
        // Generate list of tests from the source java files
        // src/test/java/com/example/dir/ClassTest.java => "com.example.dir.ClassTest"

        // Already filtered by ".*Test.java" before it arrives here
        srcFiles = J2objcUtils.fileFilter(srcFiles,
                project.j2objcConfig.translateIncludeRegex,
                project.j2objcConfig.translateExcludeRegex)
        srcFiles = J2objcUtils.fileFilter(srcFiles,
                testIncludeRegex,
                testExcludeRegex)

        // Generate Test Names
        def prefixesProperties = J2objcUtils.prefixProperties(project)
        def testNames = srcFiles.collect { file ->
            def testName = project.relativePath(file)
                            .replace('src/test/java/', '')
                            .replace('/', '.')
                            .replace('.java', '')
            // src/test/java/com/example/dir/SomeTest.java => com.example.dir.SomeTest

            // Translate test name according to prefixes.properties
            // E.g. com.example.dir.SomeTest => PREFIX.SomeTest
            def namespaceRegex = /^(([^.]+\.)+)[^.]+$/  // No match for test outside a package
            def matcher = (testName =~ namespaceRegex)
            if (matcher.find()) {
                def namespace = matcher[0][1]            // com.example.dir.
                def namespaceChopped = namespace[0..-2]  // com.example.dir
                if (prefixesProperties.containsKey(namespaceChopped)) {
                    def value = prefixesProperties.getProperty(namespaceChopped)
                    testName = testName.replace(namespace, value)
                }
            }
            return testName
        }

        def binary = "${srcFile.path}"
        println "Test Binary: " + srcFile.path

        def outputStream = new ByteArrayOutputStream()
        try {
            project.exec {
                executable binary
                args "org.junit.runner.JUnitCore"

                args cmdArgs.split()

                testNames.each { testName ->
                    args testName
                }

                errorOutput outputStream
                standardOutput outputStream
            }

        } catch (e) {
            println outputStream.toString()
            throw e
        }

        def output = outputStream.toString()
        reportFile.write(output)
        println "Test Output: ${reportFile.path}"

        // 0 tests => warn by default
        if (testExecutedCheck) {
            if (output.contains("OK (0 tests)")) {
                def message =
                        "Zero unit tests were run. Tests are strongly encouraged with J2objc:\n" +
                        "\n" +
                        "To disable this check (which is against best practice):\n" +
                        "j2objcConfig {\n" +
                        "    testExecutedCheck false\n" +
                        "}\n"
                throw new InvalidUserDataException(message)
            }
        }
    }
}


class J2objcCopyTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @InputDirectory
    File srcDir
    // TODO: declare @OutputXXX so gradle knows if task is up to date

    @TaskAction
    def destCopy() {
        if (project.j2objcConfig.destDir == null) {
            def message = "You must configure the location where the generated files are " +
                    "copied for Xcode. This is done in your build.gradle, for example:\n" +
                    "\n" +
                    "j2objcConfig {\n" +
                    "    destDir null // e.g. \"\${" + "projectDir}/../Xcode/j2objc-generated\"\n" +
                    "}"
            throw new InvalidUserDataException(message)
        }

        // Warn if deleting non-generated objc files from destDir
        def destDir = project.file(project.j2objcConfig.destDir)
        def destFiles = project.files(project.fileTree(
                dir: destDir, excludes: ["**/*.h", "**/*.m"]))
        destFiles.each { file ->
            def message =
                    "Unexpected files in destDir - this folder should contain ONLY j2objc\n" +
                    "generated files Objective-C. The folder contents are deleted to remove\n" +
                    "files that are nolonger generated. Please check the directory and remove\n" +
                    "any files that don't end with Objective-C extensions '.h' and '.m'.\n" +
                    "destDir: ${project.j2objcConfig.destDir}\n" +
                    "Unexpected file for deletion: ${file.path}"
            throw new InvalidUserDataException(message)
        }
        // TODO: better if this was a sync operation as it does deletes automatically
        println "Deleting destDir to fill with generated objc files... " + destDir.path
        project.delete destDir

        // TODO: setting to control whether to copy test files
        project.copy {
            includeEmptyDirs = false
            from srcDir
            into destDir
            // Don't copy the test code
            exclude "**/*Test.h"
            exclude "**/*Test.m"
        }
    }
}


class J2objcXcodeTask extends DefaultTask {

    // directory of the target Xcode project
    // TODO(bruno): switch to "${projectDir}/../Xcode"
    @Input
    String xcodeProjectDir = null
    // J2objc generated files are copied here, relative path to xcodeProjectDir
    // Directory contents will be deleted on every execution of the link command
    @Input
    String xcodeJ2objcGeneratedDir = "j2objc-generated"
    // Xcode target the generated files should be linked to
    @Input
    String xcodeTarget = null
    // name of the target Xcode project, e.g., MyProject.xcodeproj
    @Input
    String xcodeProject = null
    @InputDirectory
    File srcDir
    // TODO: declare @OutputXXX so gradle knows if task is up to date

    @TaskAction
    def xcode() {
        
        if (xcodeProjectDir == null) {
            def message = "You must specify the xcodeProjectDir"
            throw new InvalidUserDataException(message)
        }

        if (xcodeJ2objcGeneratedDir == null) {
            def message = "You must specify the xcodeJ2objcGeneratedDir"
            throw new InvalidUserDataException(message)
        }
        if (xcodeTarget == null) {
            def message = "You must specify the xcodeTarget"
            throw new InvalidUserDataException(message)
        }
        if (xcodeProject == null) {
            def message = "You must specify the xcodeProject"
            throw new InvalidUserDataException(message)
        }

        def srcFolder = srcDir.toString().replaceFirst(".*${project.name}","../${project.name}")
        def integratej2objcExec = "integratej2objc"

        try {
            project.exec {
                // TODO: executable integratej2objcExec
                executable "bundle"

                args "exec"
                args "integratej2objc"
                args "integrate_source"
                args "-p", "${xcodeProjectDir}"
                args "-x", "${xcodeProject}"
                args "-s", "${srcFolder}"
                args "-g", "${xcodeJ2objcGeneratedDir}"
                args "-t", "${xcodeTarget}"
            }

        } catch (Exception exception) {
            if (exception.getMessage().find("A problem occurred starting process 'command 'integratej2objc''")) {
                // TODO: fix this installation description
                def message =
                        "To install integratej2objc:\n" +
                        "https://github.com/developertown/integratej2objc/#installation"
                throw new InvalidUserDataException(message)
            }
            throw exception
        }

        def srcFilesSize = project.files(project.fileTree(dir: srcDir)).getFiles().size()
        println "Linked ${srcFilesSize} files to Xcode project ${xcodeProject}"

        // Xcode bug workaround when it fails to find files with "$$" in the filename.
        // This occurs because Xcode converts "x$$y" to "x$y" when it looks for a file.
        // Generating temp "x$y" file works. Common case is dagger generated files.
        // http://stackoverflow.com/questions/29555225/xcode-no-such-file-or-directory-if-filename-contains-sign
        def srcFiles = project.files(project.fileTree(dir: srcDir)).getFiles()
        def col = srcFiles.findAll { file -> file.name.contains("\$\$") }
        project.copy {
            from(col)
            into(srcDir)
            rename { name ->
                name.replace('\$\$', '\$')
            }
        }
    }
}


class j2objc implements Plugin<Project> {

    @Override
    void apply(Project project) {
        project.with {
            project.extensions.create("j2objcConfig", J2objcPluginExtension)

            // Produces a modest amount of output
            logging.captureStandardOutput LogLevel.INFO

            tasks.create(name: "j2objcCycleFinder", type: J2objcCycleFinderTask) {
                description "Run the cycle_finder tool on all Java source files"
                srcFiles = files(
                        fileTree(dir: projectDir,
                                include: "**/*.java",
                                exclude: project.relativePath(buildDir)))
            }

            // TODO @Bruno "build/source/apt" must be project.j2objcConfig.generatedSourceDir no idea how to set it there
            // Dependency may be added in project.plugins.withType for Java or Android plugin
            tasks.create(name: "j2objcTranslate", type: J2objcTranslateTask,
                    dependsOn: 'j2objcCycleFinder') {
                description "Translates all the java source files in to Objective-C using j2objc"
                srcFiles = files(
                        fileTree(dir: projectDir,
                                include: "**/*.java",
                                exclude: project.relativePath(buildDir)) +
                        fileTree(dir: "${buildDir}/source/apt",
                                include: "**/*.java")
                        )
                destDir = file("${buildDir}/j2objc")
            }

            tasks.create(name: "j2objcCompile", type: J2objcCompileTask,
                    dependsOn: 'j2objcTranslate') {
                description "Compiles the j2objc generated Objective-C code to 'testrunner' binary"
                srcDir = file("${buildDir}/j2objc")
                destFile = file("${buildDir}/j2objcc/testrunner")
            }

            tasks.create(name: "j2objcTest", type: J2objcTestTask,
                    dependsOn: 'j2objcCompile') {
                description 'Runs all tests in the generated Objective-C code'
                srcFile = file("${buildDir}/j2objcc/testrunner")
                // Doesn't use 'buildDir' as missing full path with --no-package-directories flag
                srcFiles = files(fileTree(dir: projectDir, includes: ["**/*Test.java"]))
            }

            tasks.create(name: 'j2objcCopy', type: J2objcCopyTask,
                    dependsOn: 'j2objcTest') {
                description 'Depends on j2objc translation and test, copies to destDir'
                srcDir = file("${buildDir}/j2objc")
            }
            
            tasks.create(name: 'j2objcXcode', type: J2objcXcodeTask,
                dependsOn: 'j2objcCopy') {
                description 'Depends on j2objc translation, link generated files to Xcode project'
                srcDir = file("${buildDir}/j2objc")
            }

            // Make sure the wider project builds successfully
            if (project.plugins.findPlugin('java')) {
                project.tasks.findByName('j2objcCycleFinder').dependsOn('test')
            } else if (project.plugins.findPlugin('com.android.application')) {
                project.tasks.findByName('j2objcCycleFinder').dependsOn('assemble')
            } else {
                def message =
                        "j2objc plugin didn't find either the expected 'java' or 'com.android.application'\n" +
                        "plugin (which was expected). When this is found, the j2objc plugin\n" +
                        "will build and run that task first to make sure the project builds correctly.\n"
                        "This will not be done here as it can't be found."
                println message
            }
        }
    }
}
