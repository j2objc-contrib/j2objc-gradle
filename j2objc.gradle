/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2015 Bruno Bowden and the other authors of j2objc-gradle (see AUTHORS file)
 *
 *
 * Description:
 * This is gradle script for j2objc (Java to Objective-C translator). This allows you to
 * share code between Android and iOS plaforms. The plugin works well with Android Studio
 * (which uses Gradle by default). The system works best if you have a large shared codebase
 * with NO Android dependencies (built with gradle). Have your main Android application depend
 * on that shared project. Within Xcode, you add the translated code and compile it.
 * j2objc by design doesn't translate UI code and expects you to write that in the
 * native language of each platform.
 *
 * For the latest version and to submit patches:
 *     https://github.com/brunobowden/j2objc-gradle
 *
 * j2objc:
 *     https://github.com/google/j2objc/wiki
 *
 *
 * Usage:
 * 1) Download a j2objc release and unzip it to a directory:
 *     https://github.com/google/j2objc/releases
 * 2) Copy this file (j2objc.gradle) next to the build.gradle file of the project to be translated
 * 3) Copy and paste the following to your project's build.gradle file
 *     (it's currently best to run "gradlew clean" when changing this configuration)

    apply from: 'j2objc.gradle'

    j2objcConfig {

        // MODIFY to where your unzipped j2objc directory is located
        // NOTE download the latest version from: https://github.com/google/j2objc/releases
        j2objcHome null  // e.g. "${projectDir}/../../j2objc or absolute path

        // MODIFY to where generated objc files should be put for Xcode project
        // NOTE these files should be checked in to the repository and updated as needed
        // NOTE this should contain ONLY j2objc generated files, other contents will be deleted
        destDir null  // e.g. "${projectDir}/../Xcode/j2objc-generated"

        // Further settings are listed in the "J2objcPluginExtension" class below
    }

 * 4) Run command to generate and copyfiles. This will only succeed if all steps succeed.
 *
 *     $ gradlew <SHARED_PROJECT>:j2objcCopy
 *
 * Commands:
 * Each one depends on the previous command
 *     j2objcCycleFinder - Find cycles that can cause memory leaks, see https://github.com/google/j2objc/wiki/Cycle-Finder-Tool
 *     j2objcTranslate   - Translates to Objective-C, depends on java or Android project if found
 *     j2objcCompile     - Compile Objective-C files and build Objective-C binary (named 'runner')
 *     j2objcTest        - Run all java tests against the Objective-C binary
 *     j2objcCopy        - Copy generated Objective-C files to Xcode project
 *     j2objcXcode       - Xcode project file import and target configuration
 *
 * Note that you can use the Gradle shorthand of "$ gradlew jCop" to do the j2objcCopy task.
 * The other shorthand expressions are "jTr", "jCom" and "jTe"
 *
 * Thanks to Peter Niederwieser and 'bigguy' from Gradleware
 */

// TODO: add plugin tests

// TODO: 'apply' should be done in build.gradle, move there as this becomes a proper plugin
apply plugin: j2objc


// Further configuration uses the following fields, setting them in j2objcConfig within build.gradle
class J2objcPluginExtension {

    // Where to copy generated files (excludes test code and executable)
    String destDir = null

    // Where to copy generated test files (excludes executable)
    // If null, generated test files are discarded for final output.
    // Can be the same directory as destDir.
    String destDirTest = null

    // Only generated source files, e.g. from dagger annotations. The script will
    // ignore changes in this directory so they must be limited to generated files.
    String[] generatedSourceDirs = []  
    
    // Path to j2objc distribution
    String j2objcHome = null


    // CYCLEFINDER
    // TODO(bruno): consider enabling cycleFinder by default
    boolean cycleFinder = false
    // Flags copied verbatim to cycle_finder command
    String cycleFinderFlags = null
    // Expected number of cycles, defaults to all those found in JRE
    // TODO(bruno): convert to a default whitelist and change expected cyles to 0
    int cycleFinderExpectedCycles = 40


    // TRANSLATE
    // Flags copied verbatim to j2objc command
    String translateFlags = "--no-package-directories"
    // -classpath library additions from ${projectDir}/lib/, e.g.: "json-20140107.jar", "somelib.jar"
    String[] translateClassPaths = []
    
    // Additional libraries that are part of the j2objc release
    // TODO: warn if different versions than testCompile from Java plugin
    // TODO: just import everything in the j2objc/lib/ directory?
    // Xcode doesn't support directories for packages, so all files must be output
    // to a single directory. This check makes sure that the name don't collide.
    boolean filenameCollisionCheck = true
    // J2objc default libraries, from $J2OBJC_HOME/lib/...
    String[] translateJ2objcLibs = [
            // Memory annotations, e.g. @Weak, @AutoreleasePool
            "j2objc_annotations.jar",
            // Libraries that have CycleFinder fixes, e.g. @Weak and code removal
            "j2objc_guava.jar", "j2objc_junit.jar", "jre_emul.jar",
            // Libraries that don't need CycleFinder fixes
            "javax.inject-1.jar", "jsr305-3.0.0.jar",
            "mockito-core-1.9.5.jar"]
    // Filter on files to translate:
    // a) Regexes are ignored if null
    // b) Matches on path + filename
    // c) Must match IncludeRegex and NOT match ExcludeRegex
    // Example:
    //     translateExcludeRegex ".*/src/(main|test)/java/com/example/EXCLUDE_DIR/.*"
    //     translateIncludeRegex ".*/TranslateOnlyMeAnd(|Test)\\.java"
    String translateExcludeRegex = null
    String translateIncludeRegex = null

    private def classNameToFileRegex(def className) {
        // Gradle java plugin convention dictates java roots end
        // with a java directory.
        return '^.*/java/' + className.replace('.', '/') + '\\.java$'
    }
    private def regexOr(def origRegex, def newPattern) {
        if (origRegex == null || origRegex.empty) {
            return newPattern
        }
        return "(${origRegex})|(${newPattern})"
    }

    // TODO: Consider improved include/exclude patterns, See issue #57.
    // Excludes a fully qualified class name from translation.
    // Example: translateExcludeClass 'java.lang.String'
    def translateExcludeClass(def className) {
        translateExcludeRegex = regexOr(translateExcludeRegex, classNameToFileRegex(className))
    }
    // Includes a fully qualified class name in translation.
    // Example: translateIncludeClass 'java.lang.String'
    def translateIncludeClass(def className) {
        translateIncludeRegex = regexOr(translateIncludeRegex, classNameToFileRegex(className))
    }

    // TODO: consider moving to include(s) / exclude(s) structure as used for filetree

    // Translation task additional paths
    // e.g., ${projectDir}/libSrc/dagger-2.0-SNAPSHOT-sources.jar:${projectDir}/libSrc/javax.inject-1-sources.jar
    // TODO dagger2 should be detected and automatically change this parameter
    String translateSourcepaths = null

    // Set to true if java project dependencies of the current project should be appended to the sourcepath
    // automatically.  You will most likely want to use --build-closure in the translateFlags as well.
    boolean appendProjectDependenciesToSourcepath = false


    // COMPILE
    // Flags copied verbatim to j2objcc command
    // J2objc default libraries
    String compileFlags = "-ObjC -lguava -ljavax_inject -ljre_emul -ljsr305 -ljunit -lmockito"


    // TEST
    // Flags copied verbatim to testrunner command
    String testFlags = ""
    // Filter tests, applied in addition to translate filters (see above)
    String testExcludeRegex = null
    String testIncludeRegex = null
    // Warn if no tests are executed
    boolean testExecutedCheck = true


    // LINK
    // directory of the target Xcode project
    String xcodeProjectDir = null // TODO(bruno): figure out what this should be "${projectDir}/Xcode"
    // J2objc generated files are copied here, relative path to xcodeProjectDir
    // Directory contents will be deleted on every execution of the link command
    String xcodeJ2objcGeneratedDir = "j2objc-generated"
    // Xcode target the generated files should be linked to
    String xcodeTarget = null
    // name of the target Xcode project, e.g., MyProject.xcodeproj
    String xcodeProject = null
}


class J2objcUtils {
    // TODO: ideally bundle j2objc binaries with plugin jar and load at runtime with
    // TODO: ClassLoader.getResourceAsStream(), extract, chmod and then execute

    static isWindows() {
        return System.getProperty("os.name").toLowerCase().contains("windows")
    }

    static def sourcepathJava(Project proj) {
        def javaRoots = []
        proj.sourceSets['main'].java.srcDirs.each {
            javaRoots += it.path
        }
        proj.sourceSets['test'].java.srcDirs.each {
            javaRoots += it.path
        }
        return javaRoots.join(':')
    }

    static def j2objcHome(Project proj) {
        def result = proj.j2objcConfig.j2objcHome
        if (result == null) {
            def message =
                "j2objcHome not set, this should be configured in the parent gradle file with " +
                "this syntax:\n" +
                "\n" +
                "j2objcConfig {\n" +
                "    j2objcHome null // e.g. \"\${projectDir}/../j2objc\"\n" +
                "}\n" +
                "\n" +
                "It must be the path of the unzipped j2objc release. Download releases here:\n" +
                "https://github.com/google/j2objc/releases"
            throw new InvalidUserDataException(message)
        }
        if (!proj.file(result).exists()) {
            def message = "j2objc directory not found, expected location: ${result}"
            throw new InvalidUserDataException(message)
        }
        return result
    }

    // Filters a FileCollection by path:
    // must match includeRegex and NOT match excludeRegex, regex ignored if null
    static def fileFilter(FileCollection files, String includeRegex, String excludeRegex) {
        return files.filter { file ->
            if (includeRegex == null)
                return true
            return file.path.matches(includeRegex)
        }.filter { file ->
            if (excludeRegex == null)
                return true
            return ! file.path.matches(excludeRegex)
        }
    }

    // Reads both settings from translateFlags (last flag takes precedence)
    //   --prefixes dir/prefixes.properties --prefix com.ex.dir=Short --prefix com.ex.dir2=Short2
    static def prefixProperties(Project proj) {
        Properties props = new Properties()
        def matcher = (proj.j2objcConfig.translateFlags =~ /--prefix(|es)\s+(\S+)/)
        def start = 0
        while (matcher.find(start)) {
            start = matcher.end()
            def newProps = new Properties()
            def argValue = matcher.group(2)
            if (matcher.group(1) == "es") {
                // --prefixes prefixes.properties
                // trailing space confuses FileInputStream
                def prefixesPath = argValue.trim()
                newProps.load(new FileInputStream(proj.file(prefixesPath).path))
            } else {
                // --prefix com.example.dir=CED
                newProps.load(new StringReader(argValue.trim()));
            }
            props.putAll(newProps)
        }
//        for (key in props.keys()) {
//            logger.debug key + ": " + props.getProperty(key)
//        }

        return props
    }

    static def filenameCollisionCheck(FileCollection files) {
        def nameMap = [:]
        for (file in files) {
            if (nameMap.containsKey(file.name)) {
                def prevFile = nameMap.get(file.name)
                def message =
                        "File name collision detected:\n" +
                        "  " + prevFile.path + "\n" +
                        "  " + file.path + "\n" +
                        "\n" +
                        "To disable this check (which may overwrite output files):\n" +
                        "j2objcConfig {\n" +
                        "    filenameCollisionCheck false\n" +
                        "}\n"
                throw new InvalidUserDataException(message)
            }
            nameMap.put(file.name, file)
        }
    }

    // add Java files to a FileCollection
    static def addJavaFiles(Project proj, FileCollection files, String[] generatedSourceDirs) {
        if (generatedSourceDirs.size() > 0) {
            generatedSourceDirs.each { sourceDir ->
                logger.debug "include generatedSourceDir: " + sourceDir
                def buildSrcFiles = proj.files(proj.fileTree(dir: sourceDir, includes: ["**/*.java"]))
                files += buildSrcFiles
            }
        }
        return files
    }

    static def absolutePathOrEmpty(Project proj, String[] relativePaths) {
        if (relativePaths.size() > 0) {
            def tmpPaths = ""
            relativePaths.each { relativePath ->
                logger.debug "Added to Path: " + relativePath
                tmpPaths += ":${proj.file(relativePath).path}"
            }
            return tmpPaths
        } else {
            return ""
        }
    }
    
    // -classpath javac flag generation from set of libraries (includes j2objc default libraries)
    static def getClassPathArg(Project proj, String[] libraries) {
        def classPathList = []
        // user defined libraries
        libraries.each { library ->
            def libPath = "${proj.projectDir}/lib/" + library
            classPathList += libPath
        }
        // j2objc default libraries
        proj.j2objcConfig.translateJ2objcLibs.each { library ->
            classPathList += j2objcHome(proj) + "/lib/" + library
        }
        return classPathList.join(':')
    }
    
    // checks if a pod is still integrated into a pod file 
    // return the result as well as the target line 
    // of the podspec for insertion
    static def checkPodDefExistence(File podFile, String xcodeTarget, String podName) {
        boolean podspecExists = false
        boolean isInOpenBlock = false
        List<String> lines = podFile.readLines()
        // Search for `podName` within the Xcode build target
        // `end` signifies the end of the build target
        // if the `podName` does not exist in the Xcode build target of the pod
        // it has to be added to the pod's target
        String targetPodLine = ""
        for (def line : lines) {
            if (line.contains("'${xcodeTarget}'")) {
                isInOpenBlock = true
                targetPodLine = line
            }
            if (isInOpenBlock) {
                if (line.contains(podName)) {
                    podspecExists = true
                }
            }
            if (line.contains("end")) {
                if (isInOpenBlock) {
                    isInOpenBlock = false
                    break
                }
            }
        }
        return [podspecExists, targetPodLine]
	}


    static def filterJ2objcOutputForErrorLines(String processOutput) {
        return processOutput.tokenize('\n').grep(~/^(.*: )?error:.*/).join('\n')
    }
}


class J2objcCycleFinderTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    // TODO: can't figure out how to do this for
    @InputFiles
    FileCollection srcFiles
    @OutputFile
    File reportFile = project.file("${project.buildDir}/reports/${name}.out")

    @TaskAction
    def cycleFinder() {

        if (! project.j2objcConfig.cycleFinder) {
            logger.debug "Skipping j2objcCycleFinder"
            return
        }

        def j2objcHome = J2objcUtils.j2objcHome(getProject())
        def cycleFinderExec = j2objcHome + "/cycle_finder"
        def windowsOnlyArgs = ""
        if (J2objcUtils.isWindows()) {
            cycleFinderExec = "java"
            windowsOnlyArgs = "-jar ${j2objcHome}/lib/cycle_finder.jar"
        }

        if (project.j2objcConfig.cycleFinderFlags == null) {
            def message =
                    "CycleFinder is more difficult to setup and use, though it's hoped to improve\n" +
                    "this for the future. For now there are two ways to set it up:\n" +
                    "\n" +
                    "SIMPLE: set cycleFinderFlags to empty string:\n" +
                    "    j2objcConfig {\n" +
                    "        cycleFinder true\n" +
                    "        cycleFinderFlags \"\"\n" +
                    "    }\n" +
                    "\n" +
                    "DIFFICULT:\n" +
                    "1) Download the j2objc source:\n" +
                    "    https://github.com/google/j2objc\n" +
                    "2) Within your local j2objc repo run:\n" +
                    "    \$ (cd jre_emul && make java_sources_manifest)\n" +
                    "3) Configure j2objcConfig in build.gradle so CycleFinder uses j2objc source:\n" +
                    "    j2objcConfig {\n" +
                    "        cycleFinder true\n" +
                    "        cycleFinderFlags (\n" +
                    "                \"--whitelist \${projectDir}/../../<J2OBJC_REPO>/jre_emul/cycle_whitelist.txt \\\n" +
                    "                 --sourcefilelist \${projectDir}/../../<J2OBJC_REPO>/jre_emul/build_result/java_sources.mf\")\n" +
                    "        cycleFinderExpectedCycles 0\n" +
                    "    }\n" +
                    "Also see: https://groups.google.com/forum/#!msg/j2objc-discuss/2fozbf6-liM/R83v7ffX5NMJ"
            throw new InvalidUserDataException(message)
        }

        def sourcepath = J2objcUtils.sourcepathJava(project)

        // Generated Files
        srcFiles = J2objcUtils.addJavaFiles(
                project, srcFiles, project.j2objcConfig.generatedSourceDirs)
        sourcepath += J2objcUtils.absolutePathOrEmpty(
                project, project.j2objcConfig.generatedSourceDirs)

        // Additional Sourcepaths, e.g. source jars
        if (project.j2objcConfig.translateSourcepaths) {
            logger.debug "Add to sourcepath: ${project.j2objcConfig.translateSourcepaths}"
            sourcepath += ":${project.j2objcConfig.translateSourcepaths}"
        }

        srcFiles = J2objcUtils.fileFilter(srcFiles,
                project.j2objcConfig.translateIncludeRegex,
                project.j2objcConfig.translateExcludeRegex)

        def classPathArg = J2objcUtils.getClassPathArg(
                project, project.j2objcConfig.translateClassPaths)

        def output = new ByteArrayOutputStream()
        try {
            project.exec {
                executable cycleFinderExec

                args windowsOnlyArgs.split()
                args "-sourcepath", sourcepath

                if (classPathArg.size() > 0) {
                    args "-classpath", classPathArg
                }

                args "${project.j2objcConfig.cycleFinderFlags}".split()

                srcFiles.each { file ->
                    args file.path
                }

                errorOutput output;
                standardOutput output;
            }

        } catch (e) {

            def out = output.toString()

            def matcher = (out =~ /(\d+) CYCLES FOUND/)
            if (! matcher.find()) {
                logger.error out
                throw new InvalidUserDataException("Can't find XX CYCLES FOUND")
            } else {
                def cycleCountStr = matcher[0][1]
                if (! cycleCountStr.isInteger()) {
                    logger.error out
                    throw new InvalidUserDataException("XX CYCLES FOUND isn't integer: " + matcher[0][0])
                }
                def cyclesFound = cycleCountStr.toInteger()
                if (cyclesFound != project.j2objcConfig.cycleFinderExpectedCycles) {
                    logger.error out
                    logger.error("Cycles found (" + cyclesFound + ") != cycleFinderExpectedCycles (" +
                            project.j2objcConfig.cycleFinderExpectedCycles + ")    ")
                    throw e
                }
            }
            // Suppress exception when cycles found == cycleFinderExpectedCycles
        }

        reportFile.write(output.toString())
        logger.debug "CycleFinder Output: ${reportFile.path}"
    }
}
     
      
// TODO: do translations and other tasks incrementally
class J2objcTranslateTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @InputFiles
    FileCollection srcFiles
    @OutputDirectory
    File destDir

    @TaskAction
    def translate(IncrementalTaskInputs inputs) {
        logger.debug "Source files: " + srcFiles.getFiles().size()
        FileCollection srcFilesChanged = project.files()
        inputs.outOfDate { change ->
            logger.debug "New or Updated file: " + change.file
            srcFilesChanged += project.files(change.file)
        }
        def removedFileNames = []
        inputs.removed { change ->
            logger.debug "Removed file: " + change.file.name
            def nameWithoutExt = file.name.toString().replaceFirst("\\..*","")
            removedFileNames += nameWithoutExt
        }
        logger.debug "Removed files: " + removedFileNames.size()

        logger.debug "New or Updated files: " + srcFilesChanged.getFiles().size()
        FileCollection translatedSrcFiles = srcFiles - srcFilesChanged
        logger.debug "Unchanged files: " + translatedSrcFiles.getFiles().size()
       
        def translatedFiles = 0
        if (destDir.exists()) {
            FileCollection destFiles = project.files(project.fileTree(
                        dir: destDir, includes: ["**/*.h", "**/*.m"]))
            
            // remove translated .h and .m files which has no corresponding .java files anymore
            destFiles.each {File file ->
                def nameWithoutExt = file.name.toString().replaceFirst("\\..*","")
                if (removedFileNames.contains(nameWithoutExt)) {
                    file.delete()
                }
            }
            // compute the number of translated files
            translatedFiles = destFiles.getFiles().size()
        }
        
               
        // set the srcFiles to the files which need to be translated
        srcFiles = srcFilesChanged

        
        def j2objcHome = J2objcUtils.j2objcHome(getProject())
        def j2objcExec = j2objcHome + "/j2objc"
        def windowsOnlyArgs = ""
        if (J2objcUtils.isWindows()) {
            j2objcExec = "java"
            windowsOnlyArgs = "-jar ${j2objcHome}/lib/j2objc.jar"
        } 
       
        def sourcepath = J2objcUtils.sourcepathJava(project)

        // Additional Sourcepaths, e.g. source jars
        if (project.j2objcConfig.translateSourcepaths) {
            logger.debug "Add to sourcepath: ${project.j2objcConfig.translateSourcepaths}"
            sourcepath += ":${project.j2objcConfig.translateSourcepaths}"
        }

        // Generated Files
        sourcepath += J2objcUtils.absolutePathOrEmpty(project, project.j2objcConfig.generatedSourceDirs)

        // Project Dependencies
        if (project.j2objcConfig.appendProjectDependenciesToSourcepath) {
            def depSourcePaths = []
            project.configurations.compile.allDependencies.each { dep ->
                if (dep instanceof ProjectDependency) {
                    def depProj = ((ProjectDependency)dep).getDependencyProject()
                    depSourcePaths += depProj.sourceSets.main.java.srcDirs
                }
            }
            sourcepath += ':' + depSourcePaths.join(':')
        }

        srcFiles = J2objcUtils.fileFilter(srcFiles,
                project.j2objcConfig.translateIncludeRegex,
                project.j2objcConfig.translateExcludeRegex)

        // TODO perform file collision check with already translated files in the destDir
        if (project.j2objcConfig.filenameCollisionCheck) {
            J2objcUtils.filenameCollisionCheck(srcFiles)
        }
     
        def classPathArg = J2objcUtils.getClassPathArg(
                project, project.j2objcConfig.translateClassPaths)
        
        classPathArg += ":${project.buildDir}/classes"  
        
        // add java classpath base to classpath for incremental translation
        // we have to check if translation has been done before or not
        // if it is only an incremental build we must remove the --build-closure
        // argument to make fewer translations of dependent classes 
        // NOTE: TODO there is one case which fails, when you have translated the code
        // make an incremental change which refers to a not yet translated class from a 
        // source lib. In this case due to not using --build-closure the dependent source 
        // we not be translated, this can be fixed with a clean and fresh build
        def translateFlags = "${project.j2objcConfig.translateFlags}"
        if (translatedFiles > 0) {
            translateFlags = translateFlags.toString().replaceFirst("--build-closure","").trim()
        }

        def output = new ByteArrayOutputStream()

        try {
            project.exec {
                executable j2objcExec

                args windowsOnlyArgs.split()
                args "-d", "${destDir}"
                args "-sourcepath", sourcepath

                if (classPathArg.size() > 0) {
                    args "-classpath", classPathArg
                }
                
                args translateFlags.split()

                srcFiles.each { file ->
                    args file.path
                }
                standardOutput output
                errorOutput output
            }

        } catch (e) {
            // Warn and explain typical case of Android application, then rethrow error
            if (! project.plugins.findPlugin('java')) {
                if (project.j2objcConfig.translateIncludeRegex == null &&
                    project.j2objcConfig.translateIncludeRegex == null) {

                    def message =
                        "\n" +
                        "J2objc by design will not translate your entire Android application.\n" +
                        "It focuses on the business logic, the UI should use native code:\n" +
                        "  https://github.com/google/j2objc/blob/master/README.md\n" +
                        "\n" +
                        "The best practice over time is to separate out the shared code to a\n" +
                        "distinct java project with NO android dependencies.\n" +
                        "\n" +
                        "As a step towards that, you can configure the j2objc plugin to only\n" +
                        "translate a subset of files that don't depend on Android. The settings\n" +
                        "are regular expressions on the file path. For example:\n" +
                        "\n" +
                        "j2objcConfig {\n" +
                        "    translateIncludeRegex \".*/src/main/java/com/example/TranslateThisDirectoryOnly/.*\n" +
                        "    translateExcludeRegex \".*/(SkipThisClass|AlsoSkipThisClass)\\.java\"\n" +
                        "}\n"

                    logger.warn message
                }
            }
            def processOutput = output.toString()
            logger.debug 'Translation output:'
            logger.debug processOutput
            // Put to stderr only the lines at fault.
            // We do not separate standardOutput and errorOutput in the exec
            // task, because the interleaved output is helpful for context.
            logger.error 'Error during translation:'
            logger.error J2objcUtils.filterJ2objcOutputForErrorLines(processOutput)
            // Gradle will helpfully tell the user to use --debug for more
            // output when the build fails.
            throw e
        }
        logger.debug 'Translation output:'
        logger.debug output.toString()
    }
}


class J2objcCompileTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @InputDirectory
    File srcDir
    @OutputFile
    File destFile

    @TaskAction
    def compile() {

        if (J2objcUtils.isWindows()) {
            throw new InvalidUserDataException(
                    "Windows only supports j2objc translation. To compile and test code, " +
                            "please develop on a Mac.");
        }

        def binary = J2objcUtils.j2objcHome(getProject()) + "/j2objcc"
        // TODO: copy / reference test resources

        // No include / exclude regex as unlikely for compile to fail after successful translation

        logger.debug "Compiling test binary: " + destFile.path
        project.exec {
            executable binary
            args "-I${srcDir}"
            args "-o", "${destFile.path}"

            args "${project.j2objcConfig.compileFlags}".split()

            def srcFiles = project.files(project.fileTree(
                    dir: srcDir, includes: ["**/*.h", "**/*.m"]))
            srcFiles.each { file ->
                args file.path
            }
        }
    }
}


class J2objcTestTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @InputFile
    File srcFile  // testrunner
    @InputFiles
    FileCollection srcFiles  // *Test.java
    @OutputFile
    File reportFile = project.file("${project.buildDir}/reports/${name}.out")

    @TaskAction
    def test() {
        // Generate list of tests from the source java files
        // src/test/java/com/example/dir/ClassTest.java => "com.example.dir.ClassTest"

        // Already filtered by ".*Test.java" before it arrives here
        srcFiles = J2objcUtils.fileFilter(srcFiles,
                project.j2objcConfig.translateIncludeRegex,
                project.j2objcConfig.translateExcludeRegex)
        srcFiles = J2objcUtils.fileFilter(srcFiles,
                project.j2objcConfig.testIncludeRegex,
                project.j2objcConfig.testExcludeRegex)

        // Generate Test Names
        def prefixesProperties = J2objcUtils.prefixProperties(project)
        def testNames = srcFiles.collect { file ->
            def testName = project.relativePath(file)
                            .replace('src/test/java/', '')
                            .replace('/', '.')
                            .replace('.java', '')
            // src/test/java/com/example/dir/SomeTest.java => com.example.dir.SomeTest

            // Translate test name according to prefixes.properties
            // E.g. com.example.dir.SomeTest => PREFIX.SomeTest
            def namespaceRegex = /^(([^.]+\.)+)[^.]+$/  // No match for test outside a package
            def matcher = (testName =~ namespaceRegex)
            if (matcher.find()) {
                def namespace = matcher[0][1]            // com.example.dir.
                def namespaceChopped = namespace[0..-2]  // com.example.dir
                if (prefixesProperties.containsKey(namespaceChopped)) {
                    def value = prefixesProperties.getProperty(namespaceChopped)
                    testName = testName.replace(namespace, value)
                }
            }
            return testName
        }

        def binary = "${srcFile.path}"
        logger.debug "Test Binary: " + srcFile.path

        def outputStream = new ByteArrayOutputStream()
        project.exec {
            executable binary
            args "org.junit.runner.JUnitCore"

            args "${project.j2objcConfig.testFlags}".split()

            testNames.each { testName ->
                args testName
            }

            errorOutput outputStream
            standardOutput outputStream
        }

        def output = outputStream.toString()
        reportFile.write(output)
        logger.debug "Test Output: ${reportFile.path}"

        // 0 tests => warn by default
        if (project.j2objcConfig.testExecutedCheck) {
            if (output.contains("OK (0 tests)")) {
                def message =
                        "Zero unit tests were run. Tests are strongly encouraged with J2objc:\n" +
                        "\n" +
                        "To disable this check (which is against best practice):\n" +
                        "j2objcConfig {\n" +
                        "    testExecutedCheck false\n" +
                        "}\n"
                throw new InvalidUserDataException(message)
            }
        }
    }
}


class J2objcCopyTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @InputDirectory
    File srcDir
    // TODO: declare @OutputXXX so gradle knows if task is up to date

    private def clearDestDirWithChecks(File destDir, String name) {
        def destFiles = project.files(project.fileTree(
                dir: destDir, excludes: ["**/*.h", "**/*.m"]))
        // Warn if deleting non-generated objc files from destDir
        destFiles.each { file ->
            def message =
                    "Unexpected files in $name - this folder should contain ONLY j2objc\n" +
                    "generated files Objective-C. The folder contents are deleted to remove\n" +
                    "files that are nolonger generated. Please check the directory and remove\n" +
                    "any files that don't end with Objective-C extensions '.h' and '.m'.\n" +
                    "$name: ${destDir.path}\n" +
                    "Unexpected file for deletion: ${file.path}"
            throw new InvalidUserDataException(message)
        }
        // TODO: better if this was a sync operation as it does deletes automatically
        logger.debug "Deleting $name to fill with generated objc files... " + destDir.path
        project.delete destDir
    }

    @TaskAction
    def destCopy() {
        if (project.j2objcConfig.destDir == null) {
            def message = "You must configure the location where the generated files are " +
                    "copied for Xcode. This is done in your build.gradle, for example:\n" +
                    "\n" +
                    "j2objcConfig {\n" +
                    "    destDir null // e.g. \"\${" + "projectDir}/../Xcode/j2objc-generated\"\n" +
                    "}"
            throw new InvalidUserDataException(message)
        }

        def destDir = project.file(project.j2objcConfig.destDir)
        clearDestDirWithChecks(destDir, 'destDir')

        project.copy {
            includeEmptyDirs = false
            from srcDir
            into destDir
            // TODO: this isn't precise, main source can be suffixed with Test as well.
            // Would be best to somehow keep the metadata about whether a file was from the
            // main sourceset or the test sourceset.
            // Don't copy the test code
            exclude "**/*Test.h"
            exclude "**/*Test.m"
        }

        if (project.j2objcConfig.destDirTest != null) {
            def destDirTest = project.file(project.j2objcConfig.destDirTest)
            if (destDirTest != destDir) {
                // If we want main source and test source in one directory, then don't
                // re-delete the main directory where we just put files!
                clearDestDirWithChecks(destDirTest, 'destDirTest')
            }
            project.copy {
                includeEmptyDirs = false
                from srcDir
                into destDirTest
                // Only copy the test code
                include "**/*Test.h"
                include "**/*Test.m"
            }
        } else {
            logger.debug 'Discard test sources since destDirTest == null'
        }
    }
}


/**
 * Note: This task requires https://github.com/developertown/integratej2objc
 * 
 */
class J2objcXcodeTask extends DefaultTask {

    // TODO: @Input for relevant j2objcConfig args to make task as stale
    @InputDirectory
    File srcDir
    // TODO: declare @OutputXXX so gradle knows if task is up to date

    @TaskAction
    def xcode() {
        
        if (project.j2objcConfig.xcodeProjectDir == null) {
            def message = "You must specify the xcodeProjectDir"
            throw new InvalidUserDataException(message)
        }

        if (project.j2objcConfig.xcodeJ2objcGeneratedDir == null) {
            def message = "You must specify the xcodeJ2objcGeneratedDir"
            throw new InvalidUserDataException(message)
        }
        if (project.j2objcConfig.xcodeTarget == null) {
            def message = "You must specify the xcodeTarget"
            throw new InvalidUserDataException(message)
        }
        if (project.j2objcConfig.xcodeProject == null) {
            def message = "You must specify the xcodeProject"
            throw new InvalidUserDataException(message)
        }

        def xcodeProjectDir = project.j2objcConfig.xcodeProjectDir
        def xcodeJ2objcGeneratedDir = project.j2objcConfig.xcodeJ2objcGeneratedDir
        def xcodeTarget = project.j2objcConfig.xcodeTarget
        def xcodeProject = project.j2objcConfig.xcodeProject

        def srcFolder = srcDir.toString().replaceFirst(".*${project.name}","../${project.name}")
        def integratej2objcExec = "integratej2objc"

        try {
            project.exec {
                // TODO: executable integratej2objcExec
                executable "bundle"

                args "exec"
                args "integratej2objc"
                args "integrate_source"
                args "-p", "${xcodeProjectDir}"
                args "-x", "${xcodeProject}"
                args "-s", "${srcFolder}"
                args "-g", "${xcodeJ2objcGeneratedDir}"
                args "-t", "${xcodeTarget}"                
            }

        } catch (Exception exception) {

            if (exception.getMessage().find("A problem occurred starting process 'command 'integratej2objc''")) {
                // TODO: fix this installation description
                def message =
                        "To install integratej2objc:\n" +
                        "https://github.com/developertown/integratej2objc/#installation"
                throw new InvalidUserDataException(message)
            }
            throw exception
        }

        def srcFilesSize = project.files(project.fileTree(dir: srcDir)).getFiles().size()
        logger.debug "Linked ${srcFilesSize} files to Xcode project ${xcodeProject}"

        // Xcode bug workaround when it fails to find files with "$$" in the filename.
        // This occurs because Xcode converts "x$$y" to "x$y" when it looks for a file.
        // Generating temp "x$y" file works. Common case is dagger generated files.
        // http://stackoverflow.com/questions/29555225/xcode-no-such-file-or-directory-if-filename-contains-sign
        def srcFiles = project.files(project.fileTree(dir: srcDir)).getFiles()
        def col = srcFiles.findAll { file -> file.name.contains("\$\$") }
        project.copy {
            from(col)
            into(srcDir)
            rename { name ->
                name.replace('\$\$', '\$')
            }
        }
    }
}

/*
 * TODO J2objcPodTask should replace J2objcXcodeTask task
 * Updates the Xcode project with j2objc generated files and resources.
 * This uses the CocoaPods dependency system. For more details see 
 * https://cocoapods.org/
 * It creates a podspec file and inserts it into your project's pod file.
 * If you haven't create a pod file yet you have to run `pod init` in your 
 * project folder before you run this task.
 */
class J2objcPodTask extends DefaultTask {
      
    @InputDirectory File srcDir
  
    @TaskAction
    def pod(IncrementalTaskInputs inputs) {
        
        if (project.j2objcConfig.xcodeProjectDir == null) {
            def message = "You must specify the xcodeProjectDir"
            throw new InvalidUserDataException(message)
        }
          
        if (project.j2objcConfig.xcodeTarget == null) {
            def message = "You must specify the xcodeTarget"
            throw new InvalidUserDataException(message)
        }
          
        def xcodeProjectDir = project.j2objcConfig.xcodeProjectDir
        def xcodeTarget = project.j2objcConfig.xcodeTarget
        def lineSeparator = System.getProperty("line.separator")
          
        // Resource Folder is copied to buildDir where it's accessed by the pod later
        String j2objcResourceDirName = "j2objcResources"
        String j2objcResourceDirPath = "${project.buildDir}/${j2objcResourceDirName}"
        project.delete j2objcResourceDirPath
        project.copy {
            from project.sourceSets['main'].resources.srcDirs
            into j2objcResourceDirPath
        }  
          
        // create the podspec
        def podName = project.name
        def podspecName = podName + ".podspec"
        def podVersion = project.version
        File podspecFile = new File(project.buildDir, podspecName)
        podspecFile.write("")
        // TODO s.libraries: this will not function for anyone who has their own list of linked libraries in the compileFlags
        podspecFile.append(
            "Pod::Spec.new do |s|" + lineSeparator + 
            "s.name = '${podName}'" + lineSeparator + 
            "s.version = '${podVersion}'" + lineSeparator + 
            "s.summary = 'Generated by the j2objc.gradle plugin.'" + lineSeparator + 
            "s.source_files = 'j2objc/**/*.{h,m}'" + lineSeparator + 
            "s.public_header_files = 'j2objc/**/*.h'" + lineSeparator + 
            "s.resources = '${j2objcResourceDirName}/**/*'" + lineSeparator + 
            "s.requires_arc = true" + lineSeparator + 
            "s.libraries = 'ObjC', 'guava', 'javax_inject', 'jre_emul', 'jsr305', 'z', 'icucore'" + lineSeparator + 
            "s.xcconfig = { 'HEADER_SEARCH_PATHS' => '${J2objcUtils.j2objcHome(project)}/include', 'LIBRARY_SEARCH_PATHS' => '${j2objcHome}/lib' }" + lineSeparator + 
            "end")
          
        // link the podspec in pod file
        File podFile = new File(xcodeProjectDir, "Podfile")
        if (!podFile.exists()) {
            def message = "No podfile exists at path ${xcodeProjectDir} execute 'pod init' first in your project directory"
            throw new InvalidUserDataException(message)
        }
        else {
            logger.debug "Pod exists at path: ${xcodeProjectDir}"
            // check if this podspec has been included before
            def result = J2objcUtils.checkPodDefExistence(podFile, xcodeTarget, podName) 
            boolean podIntegrationExists = result[0]
            String targetPodLine = result[1]
                          
            if (!podIntegrationExists) {
                // add pod to podfile, e.g., pod 'projectName', :path => '/pathToJ2objcProject/projectName/build'
                String text = podFile.getText()
                String replacement = targetPodLine + lineSeparator + 
                    "pod '${podName}', :path => '${project.buildDir}'"
                String newText = text.replaceFirst(targetPodLine, replacement)
                podFile.write(newText)                              
                logger.debug "Added pod ${podName} to Xcode target ${xcodeTarget} of podfile."
            }
             
            // install the pod   
            def output = new ByteArrayOutputStream()
            try {
                 project.exec {
                    workingDir xcodeProjectDir
                    executable "pod"
                    args "install"
                    standardOutput output
                    errorOutput output
                }   
            } catch (Exception exception) {
                logger.debug output.toString()
                logger.error 'Error during pod install:'

                // unrecognized errors are rethrown:    
                if (exception.getMessage().find("A problem occurred starting process 'command 'pod install''")) {
                    // TODO: fix this installation description
                    def message =
                        "To install pod: sudo gem install cocoapods \n" +
                        "See: https://cocoapods.org/"
                    throw new InvalidUserDataException(message)
                }
                throw exception
            }
            logger.debug 'Pod install output:'
            logger.debug output.toString()
        }
    }
}


class j2objc implements Plugin<Project> {

    @Override
    void apply(Project project) {
        project.with {
            // TODO: dependency on project.j2objcConfig, so any setting change
            // TODO: invalidates all (ideally some) tasks and causes a rebuild
            project.extensions.create("j2objcConfig", J2objcPluginExtension)

            // Produces a modest amount of output
            logging.captureStandardOutput LogLevel.INFO

            tasks.create(name: "j2objcCycleFinder", type: J2objcCycleFinderTask) {
                description "Run the cycle_finder tool on all Java source files"
                srcFiles = files(
                        fileTree(dir: projectDir,
                                include: "**/*.java",
                                exclude: project.relativePath(buildDir)))
            }

            // TODO @Bruno "build/source/apt" must be project.j2objcConfig.generatedSourceDirs no idea how to set it there
            // Dependency may be added in project.plugins.withType for Java or Android plugin
            tasks.create(name: "j2objcTranslate", type: J2objcTranslateTask,
                    dependsOn: 'j2objcCycleFinder') {
                description "Translates all the java source files in to Objective-C using j2objc"
                srcFiles = files(
                        fileTree(dir: projectDir,
                                include: "**/*.java",
                                exclude: project.relativePath(buildDir)) +
                        fileTree(dir: "build/source/apt",
                                include: "**/*.java")
                        )
                destDir = file("${buildDir}/j2objc")
            }

            project.tasks.create(name: "j2objcCompile", type: J2objcCompileTask,
                    dependsOn: 'j2objcTranslate') {
                description "Compiles the j2objc generated Objective-C code to 'testrunner' binary"
                srcDir = file("${buildDir}/j2objc")
                destFile = file("${buildDir}/j2objcc/testrunner")
            }

            project.tasks.create(name: "j2objcTest", type: J2objcTestTask,
                    dependsOn: 'j2objcCompile') {
                description 'Runs all tests in the generated Objective-C code'
                srcFile = file("${buildDir}/j2objcc/testrunner")
                // Doesn't use 'buildDir' as missing full path with --no-package-directories flag
                srcFiles = files(fileTree(dir: projectDir, includes: ["**/*Test.java"]))
            }

            project.tasks.create(name: 'j2objcCopy', type: J2objcCopyTask,
                    dependsOn: 'j2objcTest') {
                description 'Depends on j2objc translation and test, copies to destDir'
                srcDir = file("${buildDir}/j2objc")
            }
            
            project.tasks.create(name: 'j2objcXcode', type: J2objcXcodeTask,
                dependsOn: 'j2objcCopy') {
                description 'Depends on j2objc translation, link generated files to Xcode project'
                srcDir = file("${buildDir}/j2objc")
            }
            
            project.tasks.create(name: 'j2objcPod', type: J2objcPodTask,
                dependsOn: 'j2objcTest') {
                description 'Depends on j2objc translation, create a Pod file link it to Xcode project'
                srcDir = file("${buildDir}/j2objc")
            }    

            // Make sure the wider project builds successfully
            if (project.plugins.findPlugin('java')) {
                project.tasks.findByName('j2objcCycleFinder').dependsOn('test')
            } else if (project.plugins.findPlugin('com.android.application')) {
                project.tasks.findByName('j2objcCycleFinder').dependsOn('assemble')
            } else {
                def message =
                        "j2objc plugin didn't find either 'java' or 'com.android.application'\n" +
                        "plugin (which was expected). When this is found, the j2objc plugin\n" +
                        "will build and run that first to make sure the project builds correctly.\n"
                        "This will not be done here as it can't be found."
                logger.warn message
            }
        }
    }
}
