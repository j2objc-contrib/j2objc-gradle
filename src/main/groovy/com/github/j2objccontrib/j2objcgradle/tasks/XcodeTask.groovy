/*
 * Copyright (c) 2015 the authors of j2objc-gradle (see AUTHORS file)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.j2objccontrib.j2objcgradle.tasks

import com.github.j2objccontrib.j2objcgradle.J2objcConfig
import com.google.common.annotations.VisibleForTesting
import groovy.transform.CompileStatic
import groovy.transform.TypeCheckingMode
import org.gradle.api.DefaultTask
import org.gradle.api.InvalidUserDataException
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.WorkResult
import org.gradle.api.tasks.incremental.IncrementalTaskInputs
import org.gradle.process.ExecResult

/**
 * Updates the Xcode project with j2objc generated files and resources.
 * <p/>
 * This uses the CocoaPods dependency system. For more details see
 * https://cocoapods.org/.
 * <p/>
 * It creates a podspec file and inserts it into your project's pod file.
 * If you haven't create a pod file yet you have to run `pod init` in your
 * project folder before you run this task.
 */
@CompileStatic
class XcodeTask extends DefaultTask {

    // Generated ObjC source files
    @InputDirectory
    File srcGenDir

    // PodName, such as j2objc-shared
    @Input
    String getPodName() { "j2objc-${project.name}" }

    // CocoaPods podspec file that's used by the Podfile
    @OutputFile
    File getPodspecFile() { new File(project.buildDir, "${getPodName()}.podspec") }

    @OutputFile
    // Cast to string to avoid Groovy throwing exception on ambiguous method call: issue #226
    File getPodFile() {
        verifyXcodeArgs()
        // xcodeProjectDir is relative to projectDir if it's not an absolute path
        File xcodeProjectDir = project.file(getXcodeProjectDir())
        return new File(xcodeProjectDir, "Podfile")
    }

    // j2objcConfig dependencies for UP-TO-DATE checks
    @Input
    String getJ2objcHome() { return Utils.j2objcHome(project) }

    @Input @Optional
    String getXcodeProjectDir() { return J2objcConfig.from(project).xcodeProjectDir }

    @Input @Optional
    String getXcodeTarget() { return J2objcConfig.from(project).xcodeTarget }


    @TaskAction
    void xcodeConfig(IncrementalTaskInputs inputs) {

        verifyXcodeArgs()

        // Resource Folder is copied to buildDir where it's accessed by the pod later
        // TODO: is it necessary to copy the files or can they be referenced in place?
        String j2objcResourceDirName = 'j2objcResources'
        String j2objcResourceDirPath = "${project.buildDir}/${j2objcResourceDirName}"
        project.delete j2objcResourceDirPath
        copyResources(j2objcResourceDirPath)

        // podspec paths must be relative to podspec file, which is in buildDir
        String srcGenDirRelativeToBuildDir = project.buildDir.toURI().relativize(srcGenDir.toURI())
        // File("${project.buildDir}/j2objc") => "j2objc/"

        // podspec creation
        // TODO: allow custom list of libraries
        // TODO: Need to specify the release and debug library search paths separately.
        // Line separator assumed to be "\n" as this task can only be run on a Mac
        String podspecFileContents =
                "Pod::Spec.new do |s|\n" +
                "s.name = '${getPodName()}'\n" +
                "s.version = '1.0'\n" +
                "s.summary = 'Generated by the J2ObjC Gradle Plugin.'\n" +
                "s.source_files = '${srcGenDirRelativeToBuildDir}**/*.{h}'\n" +
                "s.public_header_files = '${srcGenDirRelativeToBuildDir}**/*.h'\n" +
                "s.resources = '${j2objcResourceDirName}/**/*'\n" +
                "s.requires_arc = true\n" +
                "s.preserve_paths = '${srcGenDirRelativeToBuildDir}**/*.a'\n" +
                "s.libraries = 'ObjC', 'guava', 'javax_inject', 'jre_emul', 'jsr305', 'z', 'icucore', '${project.name}-j2objc'\n" +
                "s.xcconfig = { 'HEADER_SEARCH_PATHS' => '${getJ2objcHome()}/include', " +
                "'LIBRARY_SEARCH_PATHS' => '${getJ2objcHome()}/lib ${project.buildDir}/j2objcOutputs/lib/iosDebug' }\n" +
                "end\n"
        logger.debug('podspecFileContents creation...\n\n' + podspecFileContents)
        File podspecFile = getPodspecFile()
        podspecFile.write(podspecFileContents)

        // link the podspec in pod file
        File podFile = getPodFile()
        if (!podFile.exists()) {
            // TODO: offer to run the setup commands
            String xcodeAbsPath = project.file(getXcodeProjectDir()).absolutePath
            String message =
                    "No podfile exists in the xcodeProjectDir directory:\n" +
                    "    ${podFile.path}\n" +
                    "\n" +
                    "The Podfile needes to be created with this command:\n" +
                    "    (cd $xcodeAbsPath && pod init)\n" +
                    "\n" +
                    "If the pod command isn't found, then install CocoaPods:\n" +
                    "    sudo gem install cocoapods"
            throw new InvalidUserDataException(message)
        } else {
            logger.debug("Pod exists at path: ${getXcodeProjectDir()}")
            // TODO: should use relative path, see if that's possible
            writeUpdatedPodFileIfNeeded(podFile, getXcodeTarget(), getPodName(), project.buildDir.path)

            // install the pod
            ByteArrayOutputStream output = new ByteArrayOutputStream()
            try {
                execPod(output)
            } catch (Exception exception) {
                logger.error(output.toString())

                if (exception.getMessage().find(
                        "A problem occurred starting process 'command 'pod install''")) {
                    String message =
                            'Fix this by installing CocoaPods:\n' +
                            '    sudo gem install cocoapods\n' +
                            '\n' +
                            'See: https://cocoapods.org/'
                    throw new InvalidUserDataException(message)
                }
                // unrecognized errors are rethrown:
                throw exception
            }
            logger.debug('Pod install output:')
            logger.debug(output.toString())
        }
    }

    @CompileStatic(TypeCheckingMode.SKIP)
    WorkResult copyResources(String j2objcResourceDirPath) {
        return project.copy {
            Utils.srcSet(project, 'main', 'resources').srcDirs.each {
                from it
            }
            into j2objcResourceDirPath
        }
    }

    @CompileStatic(TypeCheckingMode.SKIP)
    ExecResult execPod(ByteArrayOutputStream output) {
        return project.exec {
            workingDir getXcodeProjectDir()
            executable 'pod'
            args 'install'
            standardOutput output
            errorOutput output
        }
    }

    @VisibleForTesting
    void verifyXcodeArgs() {
        if (getXcodeProjectDir() == null ||
            getXcodeTarget() == null) {
            String message =
                    'Xcode settings need to be configured in this project\'s build.gradle:\n' +
                    '\n' +
                    'j2objcConfig {\n' +
                    '    xcodeProjectDir \'../ios\'\n' +
                    '    xcodeTarget \'<TARGET_NAME>\'\n' +
                    '}\n'
            throw new InvalidUserDataException(message)
        }
    }

    /**
     * Modify in place the existing podFile.
     */
    @VisibleForTesting
    static void writeUpdatedPodFileIfNeeded(
            File podFile, String xcodeTarget, String podName, String podPath) {

        List<String> podFileLines = podFile.readLines()
        List<String> newPodFileLines = getPodFileLinesIfChanged(
                podFileLines, xcodeTarget, podName, podPath)

        // Write file only if it's changed
        if (newPodFileLines != null) {
            podFile.write(newPodFileLines.join("\n"))
        }
    }

    /**
     * Modify the existing podFile and return the new contents.
     *
     * @return null if file doesn't need modification, otherwise modified copy of podFile
     */
    @VisibleForTesting
    static List<String> getPodFileLinesIfChanged(
            List<String> oldPodFileLines, String xcodeTarget, String podName, String podPath) {

        List<String> newPodFileLines = new ArrayList<>()

        // Search for pod within the xcodeTarget, until "end" is found for that target
        // Either update pod line in place or add line if pod doesn't exist
        String podMatchedLine = "pod '$podName'"
        String newPodPathLine = "pod '$podName', :path => '$podPath'"
        boolean withinXcodeTarget = false
        boolean podNameWritten = false

        oldPodFileLines.each { String line ->

            // Copies each line to newPodFileLines, unless skipped
            boolean skipWritingLine = false

            // Find xcodeTarget within single quote marks
            if (line.contains("'$xcodeTarget'")) {
                withinXcodeTarget = true

            } else if (withinXcodeTarget) {
                if (line.contains(podMatchedLine)) {
                    // skip copying this line
                    skipWritingLine = true
                    if (podNameWritten) {
                        // repeated podName lines, drop them as they should not be here
                    } else {
                        // write updated line the first time pod is seen
                        newPodFileLines += newPodPathLine
                        podNameWritten = true
                    }
                } else if (line.contains('end')) {
                    if (!podNameWritten) {
                        // no existing podName, so write that additional line
                        newPodFileLines += newPodPathLine
                        podNameWritten = true
                    }
                }
            }

            if (!skipWritingLine) {
                newPodFileLines += line
            }
        }

        if (!podNameWritten) {
            throw new InvalidUserDataException(
                    "Unable to modify PodFile, likely unable to find target $xcodeTarget.")
        }

        if (oldPodFileLines == newPodFileLines) {
            // PodFile unmodified
            return null
        } else {
            return newPodFileLines
        }
    }
}
